<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sizedness-in-rust - rust_kr</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust_kr</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/YoungHaKim7/rust_kr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sizedness-in-rust"><a class="header" href="#sizedness-in-rust">Sizedness-in-rust</a></h1>
<ul>
<li>ìë£Œ ì¶œì²˜ í•œê¸€ë¡œ ë²ˆì—­í•¨ : <a href="https://github.com/pretzelhammer/rust-blog">https://github.com/pretzelhammer/rust-blog</a>
<ul>
<li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md</a></li>
</ul>
</li>
</ul>
<h1 id="sizedness-in-rust-1"><a class="header" href="#sizedness-in-rust-1">Sizedness in Rust</a></h1>
<ul>
<li><em>22 July 2020 Â· #rust Â· #sizedness</em></li>
</ul>
<h1 id="link"><a class="header" href="#link">link</a></h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#sizedness">Sizedness</a></li>
<li><a href="#sized-trait"><code>Sized</code> Trait</a></li>
<li><a href="#sized-in-generics"><code>Sized</code> in Generics</a></li>
<li><a href="#unsized-types">Unsized Types</a>
<ul>
<li><a href="#slices">Slices</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#trait-object-limitations">Trait Object Limitations</a>
<ul>
<li><a href="#cannot-cast-unsized-types-to-trait-objects">Cannot Cast Unsized Types to Trait Objects</a></li>
<li><a href="#cannot-create-multi-trait-objects">Cannot create Multi-Trait Objects</a></li>
</ul>
</li>
<li><a href="#user-defined-unsized-types">User-Defined Unsized Types</a></li>
</ul>
</li>
<li><a href="#zero-sized-types">Zero-Sized Types</a>
<ul>
<li><a href="#unit-type">Unit Type</a></li>
<li><a href="#user-defined-unit-structs">User-Defined Unit Structs</a></li>
<li><a href="#never-type">Never Type</a></li>
<li><a href="#user-defined-pseudo-never-types">User-Defined Pseudo Never Types</a></li>
<li><a href="#phantomdata">PhantomData</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<hr />
<h2 id="intro"><a class="header" href="#intro">Intro<a href="#link">|ğŸ”|</a></a></h2>
<ul>
<li>
<p>Sizedness is lowkey one of the most important concepts to understand in Rust. It intersects a bunch of other language features in often subtle ways and only rears its ugly head in the form of <em>"x doesn't have size known at compile time"</em> error messages which every Rustacean is all too familiar with. In this article we'll explore all flavors of sizedness from sized types, to unsized types, to zero-sized types while examining their use-cases, benefits, pain points, and workarounds.</p>
<ul>
<li>í¬ê¸°ëŠ” ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì´í•´í•´ì•¼ í•  ê°€ì¥ ì¤‘ìš”í•œ ê°œë… ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì´ ê°œë…ì€ ì¢…ì¢… ë¯¸ë¬˜í•œ ë°©ì‹ìœ¼ë¡œ ë‹¤ë¥¸ ì–¸ì–´ ê¸°ëŠ¥ì„ ë§ì´ êµì°¨í•˜ë©°, ëª¨ë“  ëŸ¬ìŠ¤íŠ¸ì¡±ì´ ë„ˆë¬´ ìµìˆ™í•œ <em>"xëŠ” ì»´íŒŒì¼ ì‹œì ì— í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"</em> ì˜¤ë¥˜ ë©”ì‹œì§€ì˜ í˜•íƒœë¡œë§Œ ì¶”ì•…í•œ ë¨¸ë¦¬ë¥¼ ë“¤ë ¤ì¤ë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” í¬ê¸° ìœ í˜•ë¶€í„° í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•, í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•, í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•ì— ì´ë¥´ê¸°ê¹Œì§€ ëª¨ë“  ì¢…ë¥˜ì˜ í¬ê¸°ë¥¼ íƒìƒ‰í•˜ëŠ” ë™ì‹œì— ì‚¬ìš© ì‚¬ë¡€, ì´ì , ë¬¸ì œì  ë° í•´ê²° ë°©ë²•ì„ ì‚´í´ë´…ë‹ˆë‹¤.</li>
</ul>
</li>
<li>
<p>Table of phrases I use and what they're supposed to mean:</p>
<ul>
<li>ì œê°€ ì‚¬ìš©í•˜ëŠ” ë¬¸êµ¬ í‘œì™€ ê·¸ ì˜ë¯¸:</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Phrase</th><th>Shorthand for</th></tr></thead><tbody>
<tr><td>sizedness</td><td>property of being sized or unsized</td></tr>
<tr><td>sized type</td><td>type with a known size at compile time</td></tr>
<tr><td>1) unsized type <em>or</em><br>2) DST</td><td>dynamically-sized type, i.e. size not known at compile time</td></tr>
<tr><td>?sized type</td><td>type that may or may not be sized</td></tr>
<tr><td>unsized coercion</td><td>coercing a sized type into an unsized type</td></tr>
<tr><td>ZST</td><td>zero-sized type, i.e. instances of the type are 0 bytes in size</td></tr>
<tr><td>width</td><td>single unit of measurement of pointer width</td></tr>
<tr><td>1) thin pointer <em>or</em><br>2) single-width pointer</td><td>pointer that is <em>1 width</em></td></tr>
<tr><td>1) fat pointer <em>or</em><br>2) double-width pointer</td><td>pointer that is <em>2 widths</em></td></tr>
<tr><td>1) pointer <em>or</em><br>2) reference</td><td>some pointer of some width, width will be clarified by context</td></tr>
<tr><td>slice</td><td>double-width pointer to a dynamically sized view into some array</td></tr>
</tbody></table>
</div>
<h2 id="sizedness"><a class="header" href="#sizedness">Sizedness<a href="#link">|ğŸ”|</a></a></h2>
<ul>
<li>In Rust a type is sized if its size in bytes can be determined at compile-time. Determining a type's size is important for being able to allocate enough space for instances of that type on the stack. Sized types can be passed around by value or by reference. If a type's size can't be determined at compile-time then it's referred to as an unsized type or a DST, Dynamically-Sized Type. Since unsized types can't be placed on the stack they can only be passed around by reference. Some examples of sized and unsized types:
<ul>
<li>Rustì—ì„œ ìœ í˜•ì˜ í¬ê¸°(ë°”ì´íŠ¸)ë¥¼ ì»´íŒŒì¼ ì‹œê°„ì— ê²°ì •í•  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ëŠ” í¬ê¸°ê°€ ê²°ì •ë©ë‹ˆë‹¤. ìœ í˜•ì˜ í¬ê¸°ë¥¼ ê²°ì •í•˜ëŠ” ê²ƒì€ ìŠ¤íƒì—ì„œ í•´ë‹¹ ìœ í˜•ì˜ ì¸ìŠ¤í„´ìŠ¤ì— ì¶©ë¶„í•œ ê³µê°„ì„ í• ë‹¹í•  ìˆ˜ ìˆìœ¼ë ¤ë©´ ì¤‘ìš”í•©ë‹ˆë‹¤. í¬ê¸°ê°€ ìˆëŠ” ìœ í˜•ì€ ê°’ë³„ë¡œ ë˜ëŠ” ì°¸ì¡°ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì»´íŒŒì¼ ì‹œê°„ì— ìœ í˜•ì˜ í¬ê¸°ë¥¼ ê²°ì •í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì´ë¥¼ í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜• ë˜ëŠ” ë™ì  í¬ê¸°ê°€ ìˆëŠ” DST ìœ í˜•ì´ë¼ê³  í•©ë‹ˆë‹¤. í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•ì€ ìŠ¤íƒì— ë°°ì¹˜í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì°¸ì¡°ë¡œë§Œ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í¬ê¸°ê°€ í° ìœ í˜•ê³¼ í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•ì˜ ëª‡ ê°€ì§€ ì˜ˆì…ë‹ˆë‹¤:</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::mem::size_of;

fn main() {
    // primitives
    assert_eq!(4, size_of::&lt;i32&gt;());
    assert_eq!(8, size_of::&lt;f64&gt;());

    // tuples
    assert_eq!(8, size_of::&lt;(i32, i32)&gt;());

    // arrays
    assert_eq!(0, size_of::&lt;[i32; 0]&gt;());
    assert_eq!(12, size_of::&lt;[i32; 3]&gt;());

    struct Point {
        x: i32,
        y: i32,
    }

    // structs
    assert_eq!(8, size_of::&lt;Point&gt;());

    // enums
    assert_eq!(8, size_of::&lt;Option&lt;i32&gt;&gt;());

    // get pointer width, will be
    // 4 bytes wide on 32-bit targets or
    // 8 bytes wide on 64-bit targets
    const WIDTH: usize = size_of::&lt;&amp;()&gt;();

    // pointers to sized types are 1 width
    assert_eq!(WIDTH, size_of::&lt;&amp;i32&gt;());
    assert_eq!(WIDTH, size_of::&lt;&amp;mut i32&gt;());
    assert_eq!(WIDTH, size_of::&lt;Box&lt;i32&gt;&gt;());
    assert_eq!(WIDTH, size_of::&lt;fn(i32) -&gt; i32&gt;());

    const DOUBLE_WIDTH: usize = 2 * WIDTH;

    // unsized struct
    struct Unsized {
        unsized_field: [i32],
    }

    // pointers to unsized types are 2 widths
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;str&gt;()); // slice
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;[i32]&gt;()); // slice
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;dyn ToString&gt;()); // trait object
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;Box&lt;dyn ToString&gt;&gt;()); // trait object
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;Unsized&gt;()); // user-defined unsized type

    // unsized types
    size_of::&lt;str&gt;(); // compile error
    size_of::&lt;[i32]&gt;(); // compile error
    size_of::&lt;dyn ToString&gt;(); // compile error
    size_of::&lt;Unsized&gt;(); // compile error
}</code></pre></pre>
<ul>
<li>How we determine the size of sized types is straight-forward: all primitives and pointers have known sizes and all structs, tuples, enums, and arrays are just made up of primitives and pointers or other nested structs, tuples, enums, and arrays so we can just count up the bytes recursively, taking into account extra bytes needed for padding and alignment. We can't determine the size of unsized types for similarly straight-forward reasons: slices can have any number of elements in them and can thus be of any size at run-time and trait objects can be implemented by any number of structs or enums and thus can also be of any size at run-time.
<ul>
<li>í¬ê¸°ê°€ í° ìœ í˜•ì˜ í¬ê¸°ë¥¼ ê²°ì •í•˜ëŠ” ë°©ë²•ì€ ê°„ë‹¨í•©ë‹ˆë‹¤. ëª¨ë“  í”„ë¦¬ë¯¸í‹°ë¸Œì™€ í¬ì¸í„°ì—ëŠ” í¬ê¸°ê°€ ì•Œë ¤ì ¸ ìˆê³  ëª¨ë“  êµ¬ì¡°, íŠœí”Œ, ì—ë„˜, ì–´ë ˆì´ëŠ” í”„ë¦¬ë¯¸í‹°ë¸Œì™€ í¬ì¸í„° ë˜ëŠ” ê¸°íƒ€ ì¤‘ì²©ëœ êµ¬ì¡°, íŠœí”Œ, ì—ë„˜, ì–´ë ˆì´ë¡œ êµ¬ì„±ë˜ì–´ íŒ¨ë”©ê³¼ ì •ë ¬ì— í•„ìš”í•œ ì¶”ê°€ ë°”ì´íŠ¸ë¥¼ ê³ ë ¤í•˜ì—¬ ë°”ì´íŠ¸ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì¹´ìš´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¬ë¼ì´ìŠ¤ì—ëŠ” ì—¬ëŸ¬ ê°œì˜ ìš”ì†Œê°€ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëŸ°íƒ€ì„ì— ëª¨ë“  í¬ê¸°ê°€ ë  ìˆ˜ ìˆê³  íŠ¹ì„± ê°œì²´ëŠ” ì—¬ëŸ¬ ê°œì˜ êµ¬ì¡° ë˜ëŠ” ì—ë„˜ìœ¼ë¡œ êµ¬í˜„ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëŸ°íƒ€ì„ì— ëª¨ë“  í¬ê¸°ê°€ ë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.</li>
</ul>
</li>
</ul>
<p><strong>Pro tips</strong></p>
<ul>
<li>pointers of dynamically sized views into arrays are called slices in Rust, e.g. a <code>&amp;str</code> is a <em>"string slice"</em>, a <code>&amp;[i32]</code> is an <em>"i32 slice"</em></li>
<li>slices are double-width because they store a pointer to the array and the number of elements in the array</li>
<li>trait object pointers are double-width because they store a pointer to the data and a pointer to a vtable</li>
<li>unsized structs pointers are double-width because they store a pointer to the struct data and the size of the struct</li>
<li>unsized structs can only have 1 unsized field and it must be the last field in the struct</li>
</ul>
<p>To really hammer home the point about double-width pointers for unsized types here's a commented code example comparing arrays to slices:</p>
<ul>
<li>ë™ì  í¬ê¸°ì˜ ë·°ë¥¼ ë°°ì—´ì— ë„£ëŠ” í¬ì¸í„°ë¥¼ ëŸ¬ìŠ¤íŠ¸ì—ì„œ ìŠ¬ë¼ì´ìŠ¤ë¼ê³  í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, '&amp;str'ì€ <em>"ëˆ ìŠ¬ë¼ì´ìŠ¤"</em>, '&amp;[i32]'ëŠ” <em>"i32 ìŠ¬ë¼ì´ìŠ¤"ì…ë‹ˆë‹¤</em></li>
<li>ìŠ¬ë¼ì´ìŠ¤ëŠ” ë°°ì—´ì— ëŒ€í•œ í¬ì¸í„°ì™€ ë°°ì—´ì˜ ìš”ì†Œ ìˆ˜ë¥¼ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— ë‘ ë°° ë„ˆë¹„ì…ë‹ˆë‹¤</li>
<li>íŠ¹ì„± ê°ì²´ í¬ì¸í„°ëŠ” ë°ì´í„°ì— ëŒ€í•œ í¬ì¸í„°ì™€ vtableì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— ë‘ ë°° í­ì…ë‹ˆë‹¤</li>
<li>í¬ê¸°ê°€ ì‘ì€ êµ¬ì¡°ë¬¼ í¬ì¸í„°ëŠ” êµ¬ì¡°ë¬¼ ë°ì´í„°ì™€ êµ¬ì¡°ë¬¼ì˜ í¬ê¸°ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— ë‘ ë°° ë„ˆë¹„ì…ë‹ˆë‹¤</li>
<li>í¬ê¸°ê°€ ì‘ì€ êµ¬ì¡°ë¬¼ì—ëŠ” í¬ê¸°ê°€ ì‘ì€ í•„ë“œê°€ í•˜ë‚˜ë§Œ ìˆì„ ìˆ˜ ìˆìœ¼ë©° êµ¬ì¡°ë¬¼ì˜ ë§ˆì§€ë§‰ í•„ë“œì—¬ì•¼ í•©ë‹ˆë‹¤</li>
</ul>
<p>í¬ê¸°ê°€ í¬ì§€ ì•Šì€ ìœ í˜•ì˜ ë‘ ë°° ë„ˆë¹„ í¬ì¸í„°ì— ëŒ€í•œ ìš”ì ì„ íŒŒì•…í•˜ê¸° ìœ„í•´ ë°°ì—´ê³¼ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë¹„êµí•œ ì½”ë“œ ì˜ˆì œë¥¼ ì†Œê°œí•©ë‹ˆë‹¤:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::size_of;

const WIDTH: usize = size_of::&lt;&amp;()&gt;();
const DOUBLE_WIDTH: usize = 2 * WIDTH;

fn main() {
    // data length stored in type
    // an [i32; 3] is an array of three i32s
    let nums: &amp;[i32; 3] = &amp;[1, 2, 3];

    // single-width pointer
    assert_eq!(WIDTH, size_of::&lt;&amp;[i32; 3]&gt;());

    let mut sum = 0;

    // can iterate over nums safely
    // Rust knows it's exactly 3 elements
    for num in nums {
        sum += num;
    }

    assert_eq!(6, sum);

    // unsized coercion from [i32; 3] to [i32]
    // data length now stored in pointer
    let nums: &amp;[i32] = &amp;[1, 2, 3];

    // double-width pointer required to also store data length
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;[i32]&gt;());

    let mut sum = 0;

    // can iterate over nums safely
    // Rust knows it's exactly 3 elements
    for num in nums {
        sum += num;
    }

    assert_eq!(6, sum);
}</code></pre></pre>
<p>And here's another commented code example comparing structs to trait objects:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::size_of;

const WIDTH: usize = size_of::&lt;&amp;()&gt;();
const DOUBLE_WIDTH: usize = 2 * WIDTH;

trait Trait {
    fn print(&amp;self);
}

struct Struct;
struct Struct2;

impl Trait for Struct {
    fn print(&amp;self) {
        println!("struct");
    }
}

impl Trait for Struct2 {
    fn print(&amp;self) {
        println!("struct2");
    }
}

fn print_struct(s: &amp;Struct) {
    // always prints "struct"
    // this is known at compile-time
    s.print();
    // single-width pointer
    assert_eq!(WIDTH, size_of::&lt;&amp;Struct&gt;());
}

fn print_struct2(s2: &amp;Struct2) {
    // always prints "struct2"
    // this is known at compile-time
    s2.print();
    // single-width pointer
    assert_eq!(WIDTH, size_of::&lt;&amp;Struct2&gt;());
}

fn print_trait(t: &amp;dyn Trait) {
    // print "struct" or "struct2" ?
    // this is unknown at compile-time
    t.print();
    // Rust has to check the pointer at run-time
    // to figure out whether to use Struct's
    // or Struct2's implementation of "print"
    // so the pointer has to be double-width
    assert_eq!(DOUBLE_WIDTH, size_of::&lt;&amp;dyn Trait&gt;());
}

fn main() {
    // single-width pointer to data
    let s = &amp;Struct; 
    print_struct(s); // prints "struct"
    
    // single-width pointer to data
    let s2 = &amp;Struct2;
    print_struct2(s2); // prints "struct2"
    
    // unsized coercion from Struct to dyn Trait
    // double-width pointer to point to data AND Struct's vtable
    let t: &amp;dyn Trait = &amp;Struct;
    print_trait(t); // prints "struct"
    
    // unsized coercion from Struct2 to dyn Trait
    // double-width pointer to point to data AND Struct2's vtable
    let t: &amp;dyn Trait = &amp;Struct2;
    print_trait(t); // prints "struct2"
}</code></pre></pre>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>only instances of sized types can be placed on the stack, i.e. can be passed around by value</li>
<li>instances of unsized types can't be placed on the stack and must be passed around by reference</li>
<li>pointers to unsized types are double-width because aside from pointing to data they need to do an extra bit of bookkeeping to also keep track of the data's length <em>or</em> point to a vtable</li>
<li>í¬ê¸°ê°€ í° ìœ í˜•ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ìŠ¤íƒì— ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</li>
<li>í¬ê¸°ê°€ ì‘ì€ ìœ í˜•ì˜ ì¸ìŠ¤í„´ìŠ¤ëŠ” ìŠ¤íƒì— ë°°ì¹˜í•  ìˆ˜ ì—†ìœ¼ë©° ì°¸ì¡°í•˜ì—¬ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤</li>
<li>í¬ê¸°ê°€ ì‘ì€ ìœ í˜•ì˜ í¬ì¸í„°ëŠ” ë‘ ë°° ë„ˆë¹„ì´ë¯€ë¡œ ë°ì´í„°ë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²ƒ ì™¸ì—ë„ ë°ì´í„°ì˜ ê¸¸ì´ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ ì¶”ê°€ë¡œ ì•½ê°„ì˜ ë¶€ê¸°ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤(ë˜ëŠ” í…Œì´ë¸”ì„ ê°€ë¦¬í‚¤ëŠ” ê²ƒ)</li>
</ul>
<h2 id="sized-trait"><a class="header" href="#sized-trait"><code>Sized</code> Trait<a href="#link">|ğŸ”|</a></a></h2>
<p>The <code>Sized</code> trait in Rust is an auto trait and a marker trait.</p>
<p>Auto traits are traits that get automatically implemented for a type if it passes certain conditions. Marker traits are traits that mark a type as having a certain property. Marker traits do not have any trait items such as methods, associated functions, associated constants, or associated types. All auto traits are marker traits but not all marker traits are auto traits. Auto traits must be marker traits so the compiler can provide an automatic default implementation for them, which would not be possible if the trait had any trait items.</p>
<p>A type gets an auto <code>Sized</code> implementation if all of its members are also <code>Sized</code>. What "members" means depends on the containing type, for example: fields of a struct, variants of an enum, elements of an array, items of a tuple, and so on. Once a type has been "marked" with a <code>Sized</code> implementation that means its size in bytes is known at compile time.</p>
<p>Other examples of auto marker traits are the <code>Send</code> and <code>Sync</code> traits. A type is <code>Send</code> if it is safe to send that type across threads. A type is <code>Sync</code> if it's safe to share references of that type between threads. A type gets auto <code>Send</code> and <code>Sync</code> implementations if all of its members are also <code>Send</code> and <code>Sync</code>. What makes <code>Sized</code> somewhat special is that it's not possible to opt-out of unlike with the other auto marker traits which are possible to opt-out of.</p>
<ul>
<li>ëŸ¬ìŠ¤íŠ¸ì˜ 'ì‚¬ì´ì¦ˆ' íŠ¹ì„±ì€ ìë™ íŠ¹ì„±ê³¼ ë§ˆì»¤ íŠ¹ì„±ì…ë‹ˆë‹¤.</li>
</ul>
<p>ìë™ íŠ¹ì„±ì€ íŠ¹ì • ì¡°ê±´ì„ í†µê³¼í•˜ë©´ ìœ í˜•ì— ëŒ€í•´ ìë™ìœ¼ë¡œ êµ¬í˜„ë˜ëŠ” íŠ¹ì„±ì…ë‹ˆë‹¤. ë§ˆì»¤ íŠ¹ì„±ì€ ìœ í˜•ì´ íŠ¹ì • ì†ì„±ì„ ê°€ì§„ ê²ƒìœ¼ë¡œ í‘œì‹œë˜ëŠ” íŠ¹ì„±ì…ë‹ˆë‹¤. ë§ˆì»¤ íŠ¹ì„±ì—ëŠ” ë°©ë²•, ê´€ë ¨ í•¨ìˆ˜, ê´€ë ¨ ìƒìˆ˜ ë˜ëŠ” ê´€ë ¨ ìœ í˜•ê³¼ ê°™ì€ íŠ¹ì„± í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ëª¨ë“  ìë™ íŠ¹ì„±ì€ ë§ˆì»¤ íŠ¹ì„±ì´ì§€ë§Œ ëª¨ë“  ë§ˆì»¤ íŠ¹ì„±ì´ ìë™ íŠ¹ì„±ì¸ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ìë™ íŠ¹ì„±ì€ ë§ˆì»¤ íŠ¹ì„±ì´ì–´ì•¼ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•  ìˆ˜ ìˆìœ¼ë©°, íŠ¹ì„±ì— íŠ¹ì„± í•­ëª©ì´ ìˆëŠ” ê²½ìš° ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.</p>
<p>ëª¨ë“  êµ¬ì„±ì›ì´ 'í¬ê¸°'ì¸ ê²½ìš° ìœ í˜•ì€ ìë™ 'í¬ê¸°' êµ¬í˜„ì„ ì–»ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ "ë©¤ë²„"ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ í¬í•¨ëœ ìœ í˜•ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤. ìœ í˜•ì´ 'í¬ê¸°' êµ¬í˜„ìœ¼ë¡œ 'í‘œì‹œ'ë˜ë©´ ì»´íŒŒì¼ ì‹œ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ í•´ë‹¹ í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p>ìë™ ë§ˆì»¤ íŠ¹ì„±ì˜ ë‹¤ë¥¸ ì˜ˆë¡œëŠ” 'ë³´ë‚´ê¸°' ë° 'ë™ê¸°í™”' íŠ¹ì„±ì´ ìˆìŠµë‹ˆë‹¤. í•œ ìœ í˜•ì€ ìŠ¤ë ˆë“œ ê°„ì— í•´ë‹¹ ìœ í˜•ì„ ì „ì†¡í•˜ëŠ” ê²ƒì´ ì•ˆì „í•œ ê²½ìš° 'ë³´ë‚´ê¸°'ì…ë‹ˆë‹¤. í•œ ìœ í˜•ì€ ìŠ¤ë ˆë“œ ê°„ì— í•´ë‹¹ ìœ í˜•ì˜ ì°¸ì¡°ë¥¼ ê³µìœ í•˜ëŠ” ê²ƒì´ ì•ˆì „í•œ ê²½ìš° 'ë™ê¸°í™”'ì…ë‹ˆë‹¤. ëª¨ë“  êµ¬ì„±ì›ì´ 'ë³´ë‚´ê¸°' ë° 'ë™ê¸°í™”'ì¸ ê²½ìš° ìë™ìœ¼ë¡œ 'ë³´ë‚´ê¸°' ë° 'ë™ê¸°í™”'ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 'í¬ê¸°'ë¥¼ ë‹¤ì†Œ íŠ¹ë³„í•˜ê²Œ ë§Œë“œëŠ” ê²ƒì€ ì˜µíŠ¸ì•„ì›ƒí•  ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ìë™ ë§ˆì»¤ íŠ¹ì„±ê³¼ ë‹¬ë¦¬ ì˜µíŠ¸ì•„ì›ƒí•  ìˆ˜ ì—†ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]

<span class="boring">fn main() {
</span>// this type is Sized, Send, and Sync
struct Struct;

// opt-out of Send trait
impl !Send for Struct {} // âœ…

// opt-out of Sync trait
impl !Sync for Struct {} // âœ…

// can't opt-out of Sized
impl !Sized for Struct {} // âŒ
<span class="boring">}</span></code></pre></pre>
<p>This seems reasonable since there might be reasons why we wouldn't want our type to be sent or shared across threads, however it's hard to imagine a scenario where we'd want the compiler to "forget" the size of our type and treat it as an unsized type as that offers no benefits and merely makes the type more difficult to work with.</p>
<p>Also, to be super pedantic <code>Sized</code> is not technically an auto trait since it's not defined using the <code>auto</code> keyword but the special treatment it gets from the compiler makes it behave very similarly to auto traits so in practice it's okay to think of it as an auto trait.</p>
<ul>
<li>ìŠ¤ë ˆë“œ ê°„ì— ìš°ë¦¬ ìœ í˜•ì„ ì „ì†¡í•˜ê±°ë‚˜ ê³µìœ í•˜ëŠ” ê²ƒì„ ì›í•˜ì§€ ì•ŠëŠ” ì´ìœ ê°€ ìˆì„ ìˆ˜ ìˆì§€ë§Œ, ì»´íŒŒì¼ëŸ¬ê°€ ìš°ë¦¬ ìœ í˜•ì˜ í¬ê¸°ë¥¼ 'ìŠê³ ' í¬ê¸°ê°€ ì—†ëŠ” ìœ í˜•ìœ¼ë¡œ ì·¨ê¸‰í•˜ì—¬ í˜œíƒì„ ì œê³µí•˜ì§€ ì•Šê³  ìœ í˜•ì„ ì‘ì—…í•˜ê¸° ì–´ë µê²Œ ë§Œë“œëŠ” ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìƒìƒí•˜ê¸°ëŠ” ì–´ë µìŠµë‹ˆë‹¤.</li>
</ul>
<p>ë˜í•œ ì´ˆí˜„í•™ì ì¸ 'ì‚¬ì´ì¦ˆ'ëŠ” 'ìë™' í‚¤ì›Œë“œë¡œ ì •ì˜ë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì—„ë°€íˆ ë§í•˜ë©´ ìë™ íŠ¹ì„±ì´ ì•„ë‹ˆì§€ë§Œ ì»´íŒŒì¼ëŸ¬ë¡œë¶€í„° ë°›ëŠ” íŠ¹ë³„í•œ ëŒ€ìš°ë¡œ ì¸í•´ ìë™ íŠ¹ì„±ê³¼ ë§¤ìš° ìœ ì‚¬í•˜ê²Œ í–‰ë™í•˜ë¯€ë¡œ ì‹¤ì œë¡œëŠ” ìë™ íŠ¹ì„±ìœ¼ë¡œ ìƒê°í•´ë„ ê´œì°®ìŠµë‹ˆë‹¤.</p>
<p><strong>Key Takeaways</strong></p>
<ul>
<li><code>Sized</code> is an "auto" marker trait</li>
</ul>
<h2 id="sized-in-generics"><a class="header" href="#sized-in-generics"><code>Sized</code> in Generics<a href="#link">|ğŸ”|</a></a></h2>
<p>It's not immediately obvious that whenever we write any generic code every generic type parameter gets auto-bound with the <code>Sized</code> trait by default.</p>
<ul>
<li>ì¼ë°˜ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œë§ˆë‹¤ ëª¨ë“  ì¼ë°˜ ìœ í˜• ë§¤ê°œ ë³€ìˆ˜ê°€ ê¸°ë³¸ì ìœ¼ë¡œ 'í¬ê¸°' íŠ¹ì„±ìœ¼ë¡œ ìë™ ë°”ì¸ë”©ëœë‹¤ëŠ” ê²ƒì´ ì¦‰ì‹œ ëª…í™•í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this generic function...
fn func&lt;T&gt;(t: T) {}

// ...desugars to...
fn func&lt;T: Sized&gt;(t: T) {}

// ...which we can opt-out of by explicitly setting ?Sized...
fn func&lt;T: ?Sized&gt;(t: T) {} // âŒ

// ...which doesn't compile since it doesn't have
// a known size so we must put it behind a pointer...
fn func&lt;T: ?Sized&gt;(t: &amp;T) {} // âœ…
fn func&lt;T: ?Sized&gt;(t: Box&lt;T&gt;) {} // âœ…
<span class="boring">}</span></code></pre></pre>
<p><strong>Pro tips</strong></p>
<ul>
<li><code>?Sized</code> can be pronounced <em>"optionally sized"</em> or <em>"maybe sized"</em> and adding it to a type parameter's bounds allows the type to be sized or unsized</li>
<li><code>?Sized</code> in general is referred to as a <em>"widening bound"</em> or a <em>"relaxed bound"</em> as it relaxes rather than constrains the type parameter</li>
<li><code>?Sized</code> is the only relaxed bound in Rust</li>
</ul>
<p>So why does this matter? Well, any time we're working with a generic type and that type is behind a pointer we almost always want to opt-out of the default <code>Sized</code> bound to make our function more flexible in what argument types it will accept. Also, if we don't opt-out of the default <code>Sized</code> bound we'll eventually get some surprising and confusing compile error messages.</p>
<p>Let me take you on the journey of the first generic function I ever wrote in Rust. I started learning Rust before the <code>dbg!</code> macro landed in stable so the only way to print debug values was to type out <code>println!("{:?}", some_value);</code> every time which is pretty tedious so I decided to write a <code>debug</code> helper function like this:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

fn debug&lt;T: Debug&gt;(t: T) { // T: Debug + Sized
    println!("{:?}", t);
}

fn main() {
    debug("my str"); // T = &amp;str, &amp;str: Debug + Sized âœ…
}</code></pre></pre>
<p>So far so good, but the function takes ownership of any values passed to it which is kinda annoying so I changed the function to only take references instead:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

fn dbg&lt;T: Debug&gt;(t: &amp;T) { // T: Debug + Sized
    println!("{:?}", t);
}

fn main() {
    dbg("my str"); // &amp;T = &amp;str, T = str, str: Debug + !Sized âŒ
}</code></pre></pre>
<p>Which now throws this error:</p>
<pre><code class="language-none">error[E0277]: the size for values of type `str` cannot be known at compilation time
 --&gt; src/main.rs:8:9
  |
3 | fn dbg&lt;T: Debug&gt;(t: &amp;T) {
  |        - required by this bound in `dbg`
...
8 |     dbg("my str");
  |         ^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `str`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
help: consider relaxing the implicit `Sized` restriction
  |
3 | fn dbg&lt;T: Debug + ?Sized&gt;(t: &amp;T) {
  |   
</code></pre>
<p>When I first saw this I found it incredibly confusing. Despite making my function more restrictive in what arguments it takes than before it now somehow throws a compile error! What is going on?</p>
<p>I've already kinda spoiled the answer in the code comments above, but basically: Rust performs pattern matching when resolving <code>T</code> to its concrete types during compilation. Here's a couple tables to help clarify:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th><code>T</code></th><th><code>&amp;T</code></th></tr></thead><tbody>
<tr><td><code>&amp;str</code></td><td><code>T</code> = <code>&amp;str</code></td><td><code>T</code> = <code>str</code></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Type</th><th><code>Sized</code></th></tr></thead><tbody>
<tr><td><code>str</code></td><td>âŒ</td></tr>
<tr><td><code>&amp;str</code></td><td>âœ…</td></tr>
<tr><td><code>&amp;&amp;str</code></td><td>âœ…</td></tr>
</tbody></table>
</div>
<p>This is why I had to add a <code>?Sized</code> bound to make the function work as intended after changing it to take references. The working function below:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

fn debug&lt;T: Debug + ?Sized&gt;(t: &amp;T) { // T: Debug + ?Sized
    println!("{:?}", t);
}

fn main() {
    debug("my str"); // &amp;T = &amp;str, T = str, str: Debug + !Sized âœ…
}</code></pre></pre>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>all generic type parameters are auto-bound with <code>Sized</code> by default</li>
<li>if we have a generic function which takes an argument of some <code>T</code> behind a pointer, e.g. <code>&amp;T</code>, <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, et cetera, then we almost always want to opt-out of the default <code>Sized</code> bound with <code>T: ?Sized</code></li>
</ul>
<hr />
<hr />
<h2 id="unsized-types"><a class="header" href="#unsized-types">Unsized Types<a href="#link">|ğŸ”|</a></a></h2>
<h3 id="slices"><a class="header" href="#slices">Slices<a href="#link">|ğŸ”|</a></a></h3>
<p>The most common slices are string slices <code>&amp;str</code> and array slices <code>&amp;[T]</code>. What's nice about slices is that many other types coerce to them, so leveraging slices and Rust's auto type coercions allow us to write flexible APIs.</p>
<p>Type coercions can happen in several places but most notably on function arguments and at method calls. The kinds of type coercions we're interested in are deref coercions and unsized coercions. A deref coercion is when a <code>T</code> gets coerced into a <code>U</code> following a deref operation, i.e. <code>T: Deref&lt;Target = U&gt;</code>, e.g. <code>String.deref() -&gt; str</code>. An unsized coercion is when a <code>T</code> gets coerced into a <code>U</code> where <code>T</code> is a sized type and <code>U</code> is an unsized type, i.e. <code>T: Unsize&lt;U&gt;</code>, e.g. <code>[i32; 3] -&gt; [i32]</code>.</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {}
}

impl Trait for str {
    // can now call "method" on
    // 1) str or
    // 2) String since String: Deref&lt;Target = str&gt;
}
impl&lt;T&gt; Trait for [T] {
    // can now call "method" on
    // 1) any &amp;[T]
    // 2) any U where U: Deref&lt;Target = [T]&gt;, e.g. Vec&lt;T&gt;
    // 3) [T; N] for any N, since [T; N]: Unsize&lt;[T]&gt;
}

fn str_fun(s: &amp;str) {}
fn slice_fun&lt;T&gt;(s: &amp;[T]) {}

fn main() {
    let str_slice: &amp;str = "str slice";
    let string: String = "string".to_owned();

    // function args
    str_fun(str_slice);
    str_fun(&amp;string); // deref coercion

    // method calls
    str_slice.method();
    string.method(); // deref coercion

    let slice: &amp;[i32] = &amp;[1];
    let three_array: [i32; 3] = [1, 2, 3];
    let five_array: [i32; 5] = [1, 2, 3, 4, 5];
    let vec: Vec&lt;i32&gt; = vec![1];

    // function args
    slice_fun(slice);
    slice_fun(&amp;vec); // deref coercion
    slice_fun(&amp;three_array); // unsized coercion
    slice_fun(&amp;five_array); // unsized coercion

    // method calls
    slice.method();
    vec.method(); // deref coercion
    three_array.method(); // unsized coercion
    five_array.method(); // unsized coercion
}</code></pre></pre>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>leveraging slices and Rust's auto type coercions allows us to write flexible APIs</li>
</ul>
<hr />
<h3 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects<a href="#link">|ğŸ”|</a></a></h3>
<p>Traits are <code>?Sized</code> by default. This program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait: ?Sized {}
<span class="boring">}</span></code></pre></pre>
<p>Throws this error:</p>
<pre><code class="language-none">error: `?Trait` is not permitted in supertraits
 --&gt; src/main.rs:1:14
  |
1 | trait Trait: ?Sized {}
  |              ^^^^^^
  |
  = note: traits are `?Sized` by default
</code></pre>
<p>We'll get into why traits are <code>?Sized</code> by default soon but first let's ask ourselves what are the implications of a trait being <code>?Sized</code>? Let's desugar the above example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait where Self: ?Sized {}
<span class="boring">}</span></code></pre></pre>
<p>Okay, so by default traits allow <code>self</code> to possibly be an unsized type. As we learned earlier we can't pass unsized types around by value, so that limits us in the kind of methods we can define in the trait. It should be impossible to write a method the takes or returns <code>self</code> by value and yet this surprisingly compiles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(self); // âœ…
}
<span class="boring">}</span></code></pre></pre>
<p>However the moment we try to implement the method, either by providing a default implementation or by implementing the trait for an unsized type, we get compile errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(self) {} // âŒ
}

impl Trait for str {
    fn method(self) {} // âŒ
}
<span class="boring">}</span></code></pre></pre>
<p>Throws:</p>
<pre><code class="language-none">error[E0277]: the size for values of type `Self` cannot be known at compilation time
 --&gt; src/lib.rs:2:15
  |
2 |     fn method(self) {}
  |               ^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `Self`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: all local variables must have a statically known size
  = help: unsized locals are gated as an unstable feature
help: consider further restricting `Self`
  |
2 |     fn method(self) where Self: std::marker::Sized {}
  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `str` cannot be known at compilation time
 --&gt; src/lib.rs:6:15
  |
6 |     fn method(self) {}
  |               ^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `str`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: all local variables must have a statically known size
  = help: unsized locals are gated as an unstable feature
</code></pre>
<p>If we're determined to pass <code>self</code> around by value we can fix the first error by explicitly binding the trait with <code>Sized</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait: Sized {
    fn method(self) {} // âœ…
}

impl Trait for str { // âŒ
    fn method(self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Now throws:</p>
<pre><code class="language-none">error[E0277]: the size for values of type `str` cannot be known at compilation time
 --&gt; src/lib.rs:7:6
  |
1 | trait Trait: Sized {
  |              ----- required by this bound in `Trait`
...
7 | impl Trait for str {
  |      ^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `str`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</code></pre>
<p>Which is okay, as we knew upon binding the trait with <code>Sized</code> we'd no longer be able to implement it for unsized types such as <code>str</code>. If on the other hand we really wanted to implement the trait for <code>str</code> an alternative solution would be to keep the trait <code>?Sized</code> and pass <code>self</code> around by reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(&amp;self) {} // âœ…
}

impl Trait for str {
    fn method(&amp;self) {} // âœ…
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of marking the entire trait as <code>?Sized</code> or <code>Sized</code> we have the more granular and precise option of marking individual methods as <code>Sized</code> like so:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(self) where Self: Sized {}
}

impl Trait for str {} // âœ…!?

fn main() {
    "str".method(); // âŒ
}</code></pre></pre>
<p>It's surprising that Rust compiles <code>impl Trait for str {}</code> without any complaints, but it eventually catches the error when we attempt to call <code>method</code> on an unsized type so all is fine. It's a little weird but affords us some flexibility in implementing traits with some <code>Sized</code> methods for unsized types as long as we never call the <code>Sized</code> methods:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(self) where Self: Sized {}
    fn method2(&amp;self) {}
}

impl Trait for str {} // âœ…

fn main() {
    // we never call "method" so no errors
    "str".method2(); // âœ…
}</code></pre></pre>
<p>Now back to the original question, why are traits <code>?Sized</code> by default? The answer is trait objects. Trait objects are inherently unsized because any type of any size can implement a trait, therefore we can only implement <code>Trait</code> for <code>dyn Trait</code> if <code>Trait: ?Sized</code>. To put it in code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait: ?Sized {}

// the above is REQUIRED for

impl Trait for dyn Trait {
    // compiler magic here
}

// since `dyn Trait` is unsized

// and now we can use `dyn Trait` in our program

fn function(t: &amp;dyn Trait) {} // âœ…
<span class="boring">}</span></code></pre></pre>
<p>If we try to actually compile the above program we get:</p>
<pre><code class="language-none">error[E0371]: the object type `(dyn Trait + 'static)` automatically implements the trait `Trait`
 --&gt; src/lib.rs:5:1
  |
5 | impl Trait for dyn Trait {
  | ^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Trait + 'static)` automatically implements trait `Trait`
</code></pre>
<p>Which is the compiler telling us to chill since it automatically provides the implementation of <code>Trait</code> for <code>dyn Trait</code>. Again, since <code>dyn Trait</code> is unsized the compiler can only provide this implementation if <code>Trait: ?Sized</code>. If we bound <code>Trait</code> by <code>Sized</code> then <code>Trait</code> becomes <em>"object unsafe"</em> which is a term that means we can't cast types which implement <code>Trait</code> to trait objects of <code>dyn Trait</code>. As expected this program does not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait: Sized {}

fn function(t: &amp;dyn Trait) {} // âŒ
<span class="boring">}</span></code></pre></pre>
<p>Throws:</p>
<pre><code class="language-none">error[E0038]: the trait `Trait` cannot be made into an object
 --&gt; src/lib.rs:3:18
  |
1 | trait Trait: Sized {}
  |       -----  ----- ...because it requires `Self: Sized`
  |       |
  |       this trait cannot be made into an object...
2 | 
3 | fn function(t: &amp;dyn Trait) {}
  |                ^^^^^^^^^^ the trait `Trait` cannot be made into an object
</code></pre>
<p>Let's try to make an <code>?Sized</code> trait with a <code>Sized</code> method and see if we can cast it to a trait object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(self) where Self: Sized {}
    fn method2(&amp;self) {}
}

fn function(arg: &amp;dyn Trait) { // âœ…
    arg.method(); // âŒ
    arg.method2(); // âœ…
}
<span class="boring">}</span></code></pre></pre>
<p>As we saw before everything is okay as long as we don't call the <code>Sized</code> method on the trait object.</p>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>all traits are <code>?Sized</code> by default</li>
<li><code>Trait: ?Sized</code> is required for <code>impl Trait for dyn Trait</code></li>
<li>we can require <code>Self: Sized</code> on a per-method basis</li>
<li>traits bound by <code>Sized</code> can't be made into trait objects</li>
</ul>
<h3 id="trait-object-limitations"><a class="header" href="#trait-object-limitations">Trait Object Limitations</a></h3>
<p>Even if a trait is object-safe there are still sizedness-related edge cases which limit what types can be cast to trait objects and how many and what kind of traits can be represented by a trait object.</p>
<h4 id="cannot-cast-unsized-types-to-trait-objects"><a class="header" href="#cannot-cast-unsized-types-to-trait-objects">Cannot Cast Unsized Types to Trait Objects<a href="#link">|ğŸ”|</a></a></h4>
<pre><pre class="playground"><code class="language-rust">fn generic&lt;T: ToString&gt;(t: T) {}
fn trait_object(t: &amp;dyn ToString) {}

fn main() {
    generic(String::from("String")); // âœ…
    generic("str"); // âœ…
    trait_object(&amp;String::from("String")); // âœ… - unsized coercion
    trait_object("str"); // âŒ - unsized coercion impossible
}</code></pre></pre>
<p>Throws:</p>
<pre><code class="language-none">error[E0277]: the size for values of type `str` cannot be known at compilation time
 --&gt; src/main.rs:8:18
  |
8 |     trait_object("str");
  |                  ^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `str`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: required for the cast to the object type `dyn std::string::ToString`
</code></pre>
<p>The reason why passing a <code>&amp;String</code> to a function expecting a <code>&amp;dyn ToString</code> works is because of type coercion. <code>String</code> implements <code>ToString</code> and we can convert a sized type such as <code>String</code> into an unsized type such as <code>dyn ToString</code> via an unsized coercion. <code>str</code> also implements <code>ToString</code> and converting <code>str</code> into a <code>dyn ToString</code> would also require an unsized coercion but <code>str</code> is already unsized! How do we unsize an already unsized type into another unsized type?</p>
<p><code>&amp;str</code> pointers are double-width, storing a pointer to the data and the data length. <code>&amp;dyn ToString</code> pointers are also double-width, storing a pointer to the data and a pointer to a vtable. To coerce a <code>&amp;str</code> into a <code>&amp;dyn toString</code> would require a triple-width pointer to store a pointer to the data, the data length, and a pointer to a vtable. Rust does not support triple-width pointers so casting an unsized type to a trait object is not possible.</p>
<p>Previous two paragraphs summarized in a table:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Pointer to Data</th><th>Data Length</th><th>Pointer to VTable</th><th>Total Width</th></tr></thead><tbody>
<tr><td><code>&amp;String</code></td><td>âœ…</td><td>âŒ</td><td>âŒ</td><td>1 âœ…</td></tr>
<tr><td><code>&amp;str</code></td><td>âœ…</td><td>âœ…</td><td>âŒ</td><td>2 âœ…</td></tr>
<tr><td><code>&amp;String as &amp;dyn ToString</code></td><td>âœ…</td><td>âŒ</td><td>âœ…</td><td>2 âœ…</td></tr>
<tr><td><code>&amp;str as &amp;dyn ToString</code></td><td>âœ…</td><td>âœ…</td><td>âœ…</td><td>3 âŒ</td></tr>
</tbody></table>
</div>
<h4 id="cannot-create-multi-trait-objects"><a class="header" href="#cannot-create-multi-trait-objects">Cannot create Multi-Trait Objects<a href="#link">|ğŸ”|</a></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
trait Trait2 {}

fn function(t: &amp;(dyn Trait + Trait2)) {}
<span class="boring">}</span></code></pre></pre>
<p>Throws:</p>
<pre><code class="language-none">error[E0225]: only auto traits can be used as additional traits in a trait object
 --&gt; src/lib.rs:4:30
  |
4 | fn function(t: &amp;(dyn Trait + Trait2)) {}
  |                      -----   ^^^^^^
  |                      |       |
  |                      |       additional non-auto trait
  |                      |       trait alias used in trait object type (additional use)
  |                      first non-auto trait
  |                      trait alias used in trait object type (first use)
</code></pre>
<p>Remember that a trait object pointer is double-width: storing 1 pointer to the data and another to the vtable, but there's 2 traits here so there's 2 vtables which would require the <code>&amp;(dyn Trait + Trait2)</code> pointer to be 3 widths. Auto-traits like <code>Sync</code> and <code>Send</code> are allowed since they don't have methods and thus don't have vtables.</p>
<p>The workaround for this is to combine vtables by combining the traits using another trait like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(&amp;self) {}
}

trait Trait2 {
    fn method2(&amp;self) {}
}

trait Trait3: Trait + Trait2 {}

// auto blanket impl Trait3 for any type that also impls Trait &amp; Trait2
impl&lt;T: Trait + Trait2&gt; Trait3 for T {}

// from `dyn Trait + Trait2` to `dyn Trait3` 
fn function(t: &amp;dyn Trait3) {
    t.method(); // âœ…
    t.method2(); // âœ…
}
<span class="boring">}</span></code></pre></pre>
<p>One downside of this workaround is that Rust does not support supertrait upcasting. What this means is that if we have a <code>dyn Trait3</code> we can't use it where we need a <code>dyn Trait</code> or a <code>dyn Trait2</code>. This program does not compile:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {}
}

trait Trait2 {
    fn method2(&amp;self) {}
}

trait Trait3: Trait + Trait2 {}

impl&lt;T: Trait + Trait2&gt; Trait3 for T {}

struct Struct;
impl Trait for Struct {}
impl Trait2 for Struct {}

fn takes_trait(t: &amp;dyn Trait) {}
fn takes_trait2(t: &amp;dyn Trait2) {}

fn main() {
    let t: &amp;dyn Trait3 = &amp;Struct;
    takes_trait(t); // âŒ
    takes_trait2(t); // âŒ
}</code></pre></pre>
<p>Throws:</p>
<pre><code class="language-none">error[E0308]: mismatched types
  --&gt; src/main.rs:22:17
   |
22 |     takes_trait(t);
   |                 ^ expected trait `Trait`, found trait `Trait3`
   |
   = note: expected reference `&amp;dyn Trait`
              found reference `&amp;dyn Trait3`

error[E0308]: mismatched types
  --&gt; src/main.rs:23:18
   |
23 |     takes_trait2(t);
   |                  ^ expected trait `Trait2`, found trait `Trait3`
   |
   = note: expected reference `&amp;dyn Trait2`
              found reference `&amp;dyn Trait3`
</code></pre>
<p>This is because <code>dyn Trait3</code> is a distinct type from <code>dyn Trait</code> and <code>dyn Trait2</code> in the sense that they have different vtable layouts, although <code>dyn Trait3</code> does contain all the methods of <code>dyn Trait</code> and <code>dyn Trait2</code>. The workaround here is to add explicit casting methods:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {}
trait Trait2 {}

trait Trait3: Trait + Trait2 {
    fn as_trait(&amp;self) -&gt; &amp;dyn Trait;
    fn as_trait2(&amp;self) -&gt; &amp;dyn Trait2;
}

impl&lt;T: Trait + Trait2&gt; Trait3 for T {
    fn as_trait(&amp;self) -&gt; &amp;dyn Trait {
        self
    }
    fn as_trait2(&amp;self) -&gt; &amp;dyn Trait2 {
        self
    }
}

struct Struct;
impl Trait for Struct {}
impl Trait2 for Struct {}

fn takes_trait(t: &amp;dyn Trait) {}
fn takes_trait2(t: &amp;dyn Trait2) {}

fn main() {
    let t: &amp;dyn Trait3 = &amp;Struct;
    takes_trait(t.as_trait()); // âœ…
    takes_trait2(t.as_trait2()); // âœ…
}</code></pre></pre>
<p>This is a simple and straight-forward workaround that seems like something the Rust compiler could automate for us. Rust is not shy about performing type coercions as we have seen with deref and unsized coercions, so why isn't there a trait upcasting coercion? This is a good question with a familiar answer: the Rust core team is working on other higher-priority and higher-impact features. Fair enough.</p>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>Rust doesn't support pointers wider than 2 widths so
<ul>
<li>we can't cast unsized types to trait objects</li>
<li>we can't have multi-trait objects, but we can work around this by coalescing multiple traits into a single trait</li>
</ul>
</li>
</ul>
<h3 id="user-defined-unsized-types"><a class="header" href="#user-defined-unsized-types">User-Defined Unsized Types<a href="#link">|ğŸ”|</a></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Unsized {
    unsized_field: [i32],
}
<span class="boring">}</span></code></pre></pre>
<p>We can define an unsized struct by giving the struct an unsized field. Unsized structs can only have 1 unsized field and it must be the last field in the struct. This is a requirement so that the compiler can determine the starting offset of every field in the struct at compile-time, which is important for efficient and fast field access. Furthermore, a single unsized field is the most that can be tracked using a double-width pointer, as more unsized fields would require more widths.</p>
<p>So how do we even instantiate this thing? The same way we do with any unsized type: by first making a sized version of it then coercing it into the unsized version. However, <code>Unsized</code> is always unsized by definition, there's no way to make a sized version of it! The only workaround is to make the struct generic so that it can exist in both sized and unsized versions:</p>
<pre><pre class="playground"><code class="language-rust">struct MaybeSized&lt;T: ?Sized&gt; {
    maybe_sized: T,
}

fn main() {
    // unsized coercion from MaybeSized&lt;[i32; 3]&gt; to MaybeSized&lt;[i32]&gt;
    let ms: &amp;MaybeSized&lt;[i32]&gt; = &amp;MaybeSized { maybe_sized: [1, 2, 3] };
}</code></pre></pre>
<p>So what are the use-cases of this? There aren't any particularly compelling ones, user-defined unsized types are a pretty half-baked feature right now and their limitations outweigh any benefits. They're mentioned here purely for the sake of comprehensiveness.</p>
<p><strong>Fun fact:</strong> <code>std::ffi::OsStr</code> and <code>std::path::Path</code> are 2 unsized structs in the standard library that you've probably used before without realizing!</p>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>user-defined unsized types are a half-baked feature right now and their limitations outweigh any benefits</li>
</ul>
<h2 id="zero-sized-types"><a class="header" href="#zero-sized-types">Zero-Sized Types<a href="#link">|ğŸ”|</a></a></h2>
<p>ZSTs sound exotic at first but they're used everywhere.</p>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h3>
<p>The most common ZST is the unit type: <code>()</code>. All empty blocks <code>{}</code> evaluate to <code>()</code> and if the block is non-empty but the last expression is discarded with a semicolon <code>;</code> then it also evaluates to <code>()</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: () = {};
    let b: i32 = {
        5
    };
    let c: () = {
        5;
    };
}</code></pre></pre>
<p>Every function which doesn't have an explicit return type returns <code>()</code> by default.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// with sugar
fn function() {}

// desugared
fn function() -&gt; () {}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>()</code> is zero bytes all instances of <code>()</code> are the same which makes for some really simple <code>Default</code>, <code>PartialEq</code>, and <code>Ord</code> implementations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

impl Default for () {
    fn default() {}
}

impl PartialEq for () {
    fn eq(&amp;self, _other: &amp;()) -&gt; bool {
        true
    }
    fn ne(&amp;self, _other: &amp;()) -&gt; bool {
        false
    }
}

impl Ord for () {
    fn cmp(&amp;self, _other: &amp;()) -&gt; Ordering {
        Ordering::Equal
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler understands <code>()</code> is zero-sized and optimizes away interactions with instances of <code>()</code>. For example, a <code>Vec&lt;()&gt;</code> will never make any heap allocations, and pushing and popping <code>()</code> from the <code>Vec</code> just increments and decrements its <code>len</code> field:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // zero capacity is all the capacity we need to "store" infinitely many ()
    let mut vec: Vec&lt;()&gt; = Vec::with_capacity(0);
    // causes no heap allocations or vec capacity changes
    vec.push(()); // len++
    vec.push(()); // len++
    vec.push(()); // len++
    vec.pop(); // len--
    assert_eq!(2, vec.len());
}</code></pre></pre>
<p>The above example has no practical applications, but is there any situation where we can take advantage of the above idea in a meaningful way? Surprisingly yes, we can get an efficient <code>HashSet&lt;Key&gt;</code> implementation from a <code>HashMap&lt;Key, Value&gt;</code> by setting the <code>Value</code> to <code>()</code> which is exactly how <code>HashSet</code> in the Rust standard library works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// std::collections::HashSet
pub struct HashSet&lt;T&gt; {
    map: HashMap&lt;T, ()&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Takeaways</strong></p>
<ul>
<li>all instances of a ZST are equal to each other</li>
<li>Rust compiler knows to optimize away interactions with ZSTs</li>
</ul>
<h3 id="user-defined-unit-structs"><a class="header" href="#user-defined-unit-structs">User-Defined Unit Structs<a href="#link">|ğŸ”|</a></a></h3>
<p>A unit struct is any struct without any fields, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;
<span class="boring">}</span></code></pre></pre>
<p>Properties that make unit structs more useful than <code>()</code>:</p>
<ul>
<li>we can implement whatever traits we want on our own unit structs, Rust's trait orphan rules prevent us from implementing traits for <code>()</code> as it's defined in the standard library</li>
<li>unit structs can be given meaningful names within the context of our program</li>
<li>unit structs, like all structs, are non-Copy by default, which may be important in the context of our program</li>
</ul>
<h3 id="never-type"><a class="header" href="#never-type">Never Type<a href="#link">|ğŸ”|</a></a></h3>
<p>The second most common ZST is the never type: <code>!</code>. It's called the never type because it represents computations that never resolve to any value at all.</p>
<p>A couple interesting properties of <code>!</code> that make it different from <code>()</code>:</p>
<ul>
<li><code>!</code> can be coerced into any other type</li>
<li>it's not possible to create instances of <code>!</code></li>
</ul>
<p>The first interesting property is very useful for ergonomics and allows us to use handy macros like these:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// nice for quick prototyping
fn example&lt;T&gt;(t: &amp;[T]) -&gt; Vec&lt;T&gt; {
    unimplemented!() // ! coerced to Vec&lt;T&gt;
}

fn example2() -&gt; i32 {
    // we know this parse call will never fail
    match "123".parse::&lt;i32&gt;() {
        Ok(num) =&gt; num,
        Err(_) =&gt; unreachable!(), // ! coerced to i32
    }
}

fn example3(some_condition: bool) -&gt; &amp;'static str {
    if !some_condition {
        panic!() // ! coerced to &amp;str
    } else {
        "str"
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>break</code>, <code>continue</code>, and <code>return</code> expressions also have type <code>!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example() -&gt; i32 {
    // we can set the type of x to anything here
    // since the block never evaluates to any value
    let x: String = {
        return 123 // ! coerced to String
    };
}

fn example2(nums: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    let mut filtered = Vec::new();
    for num in nums {
        filtered.push(
            if *num &lt; 0 {
                break // ! coerced to i32
            } else if *num % 2 == 0 {
                *num
            } else {
                continue // ! coerced to i32
            }
        );
    }
    filtered
}
<span class="boring">}</span></code></pre></pre>
<p>The second interesting property of <code>!</code> allows us to mark certain states as impossible on a type level. Let's take this function signature as an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function() -&gt; Result&lt;Success, Error&gt;;
<span class="boring">}</span></code></pre></pre>
<p>We know that if the function returns and was successful the <code>Result</code> will contain some instance of type <code>Success</code> and if it errored <code>Result</code> will contain some instance of type <code>Error</code>. Now let's compare that to this function signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function() -&gt; Result&lt;Success, !&gt;;
<span class="boring">}</span></code></pre></pre>
<p>We know that if the function returns and was successful the <code>Result</code> will hold some instance of type <code>Success</code> and if it errored... but wait, it can never error, since it's impossible to create instances of <code>!</code>. Given the above function signature we know this function will never error. How about this function signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function() -&gt; Result&lt;!, Error&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The inverse of the previous is now true: if this function returns we know it must have errored as success is impossible.</p>
<p>A practical application of the former example would be the <code>FromStr</code> implementation for <code>String</code> as it's impossible to fail converting a <code>&amp;str</code> into a <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(never_type)]

<span class="boring">fn main() {
</span>use std::str::FromStr;

impl FromStr for String {
    type Err = !;
    fn from_str(s: &amp;str) -&gt; Result&lt;String, Self::Err&gt; {
        Ok(String::from(s))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A practical application of the latter example would be a function that runs an infinite loop that's never meant to return, like a server responding to client requests, unless there's some error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(never_type)]

<span class="boring">fn main() {
</span>fn run_server() -&gt; Result&lt;!, ConnectionError&gt; {
    loop {
        let (request, response) = get_request()?;
        let result = request.process();
        response.send(result);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The feature flag is necessary because while the never type exists and works within Rust internals using it in user-code is still considered experimental.</p>
<p><strong>Key Takeaways</strong></p>
<ul>
<li><code>!</code> can be coerced into any other type</li>
<li>it's not possible to create instances of <code>!</code> which we can use to mark certain states as impossible at a type level</li>
</ul>
<h3 id="user-defined-pseudo-never-types"><a class="header" href="#user-defined-pseudo-never-types">User-Defined Pseudo Never Types</a></h3>
<p>While it's not possible to define a type that can coerce to any other type it is possible to define a type which is impossible to create instances of such as an <code>enum</code> without any variants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
<span class="boring">}</span></code></pre></pre>
<p>This allows us to remove the feature flag from the previous two examples and implement them using stable Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}

// example 1
impl FromStr for String {
    type Err = Void;
    fn from_str(s: &amp;str) -&gt; Result&lt;String, Self::Err&gt; {
        Ok(String::from(s))
    }
}

// example 2
fn run_server() -&gt; Result&lt;Void, ConnectionError&gt; {
    loop {
        let (request, response) = get_request()?;
        let result = request.process();
        response.send(result);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is the technique the Rust standard library uses, as the <code>Err</code> type for the <code>FromStr</code> implementation of <code>String</code> is <code>std::convert::Infallible</code> which is defined as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Infallible {}
<span class="boring">}</span></code></pre></pre>
<h3 id="phantomdata"><a class="header" href="#phantomdata">PhantomData<a href="#link">|ğŸ”|</a></a></h3>
<p>The third most commonly used ZST is probably <code>PhantomData</code>. <code>PhantomData</code> is a zero-sized marker struct which can be used to "mark" a containing struct as having certain properties. It's similar in purpose to its auto marker trait cousins such as <code>Sized</code>, <code>Send</code>, and <code>Sync</code> but being a marker struct is used a little bit differently. Giving a thorough explanation of <code>PhantomData</code> and exploring all of its use-cases is outside the scope of this article so let's only briefly go over a single simple example. Recall this code snippet presented earlier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]

<span class="boring">fn main() {
</span>// this type is Send and Sync
struct Struct;

// opt-out of Send trait
impl !Send for Struct {}

// opt-out of Sync trait
impl !Sync for Struct {}
<span class="boring">}</span></code></pre></pre>
<p>It's unfortunate that we have to use a feature flag, can we accomplish the same result using only stable Rust? As we've learned, a type is only <code>Send</code> and <code>Sync</code> if all of its members are also <code>Send</code> and <code>Sync</code>, so we can add a <code>!Send</code> and <code>!Sync</code> member to <code>Struct</code> like <code>Rc&lt;()&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

// this type is not Send or Sync
struct Struct {
    // adds 8 bytes to every instance
    _not_send_or_sync: Rc&lt;()&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This is less than ideal because it adds size to every instance of <code>Struct</code> and we now also have to conjure a <code>Rc&lt;()&gt;</code> from thin air every time we want to create a <code>Struct</code>. Since <code>PhantomData</code> is a ZST it solves both of these problems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::marker::PhantomData;

type NotSendOrSyncPhantom = PhantomData&lt;Rc&lt;()&gt;&gt;;

// this type is not Send or Sync
struct Struct {
    // adds no additional size to instances
    _not_send_or_sync: NotSendOrSyncPhantom,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Takeaways</strong></p>
<ul>
<li><code>PhantomData</code> is a zero-sized marker struct which can be used to "mark" a containing struct as having certain properties</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion<a href="#link">|ğŸ”|</a></a></h2>
<ul>
<li>only instances of sized types can be placed on the stack, i.e. can be passed around by value</li>
<li>instances of unsized types can't be placed on the stack and must be passed around by reference</li>
<li>pointers to unsized types are double-width because aside from pointing to data they need to do an extra bit of bookkeeping to also keep track of the data's length <em>or</em> point to a vtable</li>
<li><code>Sized</code> is an "auto" marker trait</li>
<li>all generic type parameters are auto-bound with <code>Sized</code> by default</li>
<li>if we have a generic function which takes an argument of some <code>T</code> behind a pointer, e.g. <code>&amp;T</code>, <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, et cetera, then we almost always want to opt-out of the default <code>Sized</code> bound with <code>T: ?Sized</code></li>
<li>leveraging slices and Rust's auto type coercions allows us to write flexible APIs</li>
<li>all traits are <code>?Sized</code> by default</li>
<li><code>Trait: ?Sized</code> is required for <code>impl Trait for dyn Trait</code></li>
<li>we can require <code>Self: Sized</code> on a per-method basis</li>
<li>traits bound by <code>Sized</code> can't be made into trait objects</li>
<li>Rust doesn't support pointers wider than 2 widths so
<ul>
<li>we can't cast unsized types to trait objects</li>
<li>we can't have multi-trait objects, but we can work around this by coalescing multiple traits into a single trait</li>
</ul>
</li>
<li>user-defined unsized types are a half-baked feature right now and their limitations outweigh any benefits</li>
<li>all instances of a ZST are equal to each other</li>
<li>Rust compiler knows to optimize away interactions with ZSTs</li>
<li><code>!</code> can be coerced into any other type</li>
<li>it's not possible to create instances of <code>!</code> which we can use to mark certain states as impossible at a type level</li>
<li><code>PhantomData</code> is a zero-sized marker struct which can be used to "mark" a containing struct as having certain properties</li>
</ul>
<h2 id="discuss"><a class="header" href="#discuss">Discuss<a href="#link">|ğŸ”|</a></a></h2>
<p>Discuss this article on</p>
<ul>
<li><a href="https://users.rust-lang.org/t/blog-post-sizedness-in-rust/46293?u=pretzelhammer">official Rust users forum</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/hx2jd0/sizedness_in_rust/">learnrust subreddit</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/hxips7/sizedness_in_rust/">rust subreddit</a></li>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading<a href="#link">|ğŸ”|</a></a></h2>
<ul>
<li><a href="./common-rust-lifetime-misconceptions.html">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./tour-of-rusts-standard-library-traits.html">Tour of Rust's Standard Library Traits</a></li>
<li><a href="./chat-server.html">Beginner's Guide to Concurrent Programming: Coding a Multithreaded Chat Server using Tokio</a></li>
<li><a href="./learning-rust-in-2024.html">Learning Rust in 2024</a></li>
<li><a href="./rust-in-non-rust-servers.html">Using Rust in Non-Rust Servers to Improve Performance</a></li>
<li><a href="./restful-api-in-sync-and-async-rust.html">RESTful API in Sync &amp; Async Rust</a></li>
<li><a href="./too-many-brainfuck-compilers.html">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Advanced/dandd.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../Advanced/cpp/move_semantics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Advanced/dandd.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../Advanced/cpp/move_semantics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
